# Project Files Layout
- `tokens.py`: Contains the definition of a token and any language keywords.
- `lexer.py`: Contains the lexer which is responsible for creating tokens out of the original source text.
- `ast_nodes.py`: Contains the defintions of each Abstract Syntax Tree(AST) node which can be generated by the parser.
- `parse.py`: Contains the code for a recursive descent parser used to generate the AST from tokens created by the lexer.
- `env.py`: Contains all code related to the environment.
- `internal_error.py`: Contains a series of custom error classes which are thrown during lexing, parsing or runtime.
- `objects.py`: Contains all interpreter objects used to represent values at runtime.
- `visitor.py`: Contains all code related to the Visitor pattern used to evaluate each AST node.
- `utils.py`: Contains any utility functions used by the interpreter but not available to the user.
- `vm.py`: Contains all code related to the virtual machine.
- `stdlib`: Contains the small standard library which comes with Zai.

# Parser
Zai uses a handwritten recursive descent parser which uses the tokens generated by the lexer as input. Each function within the file `parse.py` represents one rule within the language's [grammar](/docs/grammar).

If the input provided by the lexer cannot be parsed then the parser emits an `InternalParseError` to signal this.
# Evaluation
Zai code is evaluated by "walking" the AST generated by the parser. Each AST node which can be generated has an associated `Visitor` class which is responsible for evaluating the contents of the node.

While it is possible to associate all code needed to evaluate a parser directly with each AST node, using the visitor pattern allows for more flexibilty by separating the structure of the AST from the way it is interpreted.
## Internal Object Representation
**TODO**
## Finding Imported Modules
Whenever a module is imported using either the `import MODULE_NAME` or `import MODULE_NAME as IMPORTED_NAME`, Zai will do the following:
1. Look for a file named `MODULE_NAME.zai` within the current folder where Zai was invoked.
2. If a file named `MODULE_NAME.zai` is not found within the current folder, Zai will then look for an environment variable called `ZAI_PATH`. This environment variable should be created and set by the user and should contain all paths where Zai code may be located. The syntax used should be the same as the `PATH` variable used by most shells. All directories listed are evaluated in the order that they are written.(i.e. from left to right)

An example of setting `ZAI_PATH`:
```
ZAI_PATH=$HOME/modules:$HOME/
```
When a module is imported, Zai will first look in the `$HOME/modules` folder. If the module is not there then zai will finally look into the `$HOME` folder.

If Zai cannot locate a module, a runtime error will be thrown and program execution will be terminated.
# Environment Implementation
**TODO**
# Garbage Collection
Since Zai is written in Python which is already garbage collected, there is no need to implement a garbage collector for internal objects.